#define init

//check for debug
global.debug = false;
for(var p = 0; p < maxp; p++){
	var alias = player_get_alias(p);
	if alias == "Golden Epsilon" ||
	alias == "blaac" ||
	alias == "Dragonstrive" ||
	alias == "wigglercola" {
		global.debug = true;
	}
}

//Chat anticheat vars
global.active = true;
global.cheating = [];
global.regChat = [];
for(var p = 0; p < maxp; p++){
	array_push(global.cheating, 0);
	array_push(global.regChat, 0);
}

//other Vars
global.modes = [
	{
		name: "Invalid",
		folder: "Invalid"
	},
	{
		name: "Vanilla Daily",
		folder: "VDailies"
	},
	{
		name: "Modded Daily",
		folder: "Dailies"
	},
	{
		name: "Modded Weekly",
		folder: "Weeklies",
		weekly: true
	},
	{
		name: "Extra",
		folder: "Extras"
	}
]
global.currentMode = "";
global.modeType = "";
global.options = {
	area_display: true,
	mini_intros: true,
	ntt_characters: true
}

global.newLevel = instance_exists(GenCont);

global.newjsonstr = ""//Hack

global.canStart = false;
global.qualified = false;
global.endData = {
	alias: "",
	data: []
};
global.start = false;
global.finished = true;
global.leaderboard = [[], [], []]
global.data = []
global.unixTime = 0;
global.currentDate = "";
global.currentWeek = "";
global.countdownStart = floor(current_frame/30)
global.countdown = 0;

global.forks = 0;

if(fork()){
	wait file_load("options.json");
	var optstr = string_load("options.json")
	if is_string(optstr){
		var options = json_decode(optstr);
		if options != json_error {
			var i = 0;
			while(lq_get_key(options, i) != undefined){
				if lq_exists(global.options, lq_get_key(options, i)){
					lq_set(global.options, lq_get_key(options, i), lq_get_value(options, i))
				}
				i++;
			}
		}
	}
	exit;
}

wait(3);

cansideload = 1;

//Eventually move past the mode check, but for now it should be here
checkForUpdates("weeklies", "GoldenEpsilon/NTT-Modded-Weeklies")

getCurrentDate();

loadModes();

loadLeaderboards();

wait file_load("modestorage.txt");
if file_exists("modestorage.txt") {
	global.currentMode = string_load("modestorage.txt");
	file_delete("modestorage.txt");
	file_unload("modestorage.txt");
}

while(global.currentMode == "") {wait(0)}

if get_current_data().valid {
	if !global.debug {
		global.NoChat = instance_create(0,0,SetKey);
		global.NoChat.persistent = true;
	}
	global.qualified = true;
	current_time_scale = 1/(room_speed/30);
	if(global.qualified == true && !instance_exists(CharSelect)){
		with(Player){
			instance_destroy();
			global.qualified = false;
		}
		with(Revive){
			instance_destroy();
			global.qualified = false;
		}
		trace("Disqualified for uploading results, as you loaded the mod while in a run. Go back to the character select screen to start a new run.");
	}
}

trace("Today is " + global.currentDate);

#define loadAllMods()
global.canStart = false;

UberCont.hardmode = false;
if(game_width == 426 && game_height != 240){
	game_set_size(426, 240);
}else if(game_width == 280 && game_height != 280){
	game_set_size(280, 280);
}else if game_width != 320 || game_height != 240 {
	game_set_size(320, 240);
}

var aud = 0;
while(audio_exists(aud)){
	sound_restore(aud)
	aud++;
}

var i = 0;
for(i = 0; i < array_length(mod_get_names("mod")); i=i){
	var modname = mod_get_names("mod")[i];
	if(modname != mod_current && 
		modname != "GCFix" && 
		modname != "areadisplay" && 
		modname != "miniintros" && 
		modname != "mw_ui" && 
		modname != "mw_ui_weapons" && 
		modname != "mw_ui_crowns" && 
		modname != "selectui" && 
		modname != "mw_ui_options" && 
		modname != "mw_ui_mods"){
			mod_unload(mod_get_names("mod")[i]);
	} else {
		i++;
	}
}
for(i = 0; i < array_length(mod_get_names("weapon")); i=i){
	var modname = mod_get_names("weapon")[i];
	if(modname != "mw_ui_start"){
		mod_unload(mod_get_names("weapon")[i]);
	} else {
		i++;
	}
}
var areamods = mod_get_names("area")
for(i = 0; i < array_length(areamods); i++){
	mod_unload(areamods[i]);
}
var crownmods = mod_get_names("crown")
for(i = 0; i < array_length(crownmods); i++){
	mod_unload(crownmods[i]);
}
var racemods = mod_get_names("race")
for(i = 0; i < array_length(racemods); i++){
	mod_unload(racemods[i]);
}
var skillmods = mod_get_names("skill")
for(i = 0; i < array_length(skillmods); i++){
	mod_unload(skillmods[i]);
}
var skinmods = mod_get_names("skin")
for(i = 0; i < array_length(skinmods); i++){
	mod_unload(skinmods[i]);
}
if "mods" in get_current_data() {
	global.loadticket = [];
	with get_current_data().mods {
		if(fork()){
			array_push(global.loadticket, self.name);
			if "patches" not in self {
				self.patches = [];
			}
			if "globals" not in self {
				self.globals = [];
			}
			switch self.download_type {
				case "itch":
					var api_key = "mD4JDfwnLXlsxPChbvGnttoOqHSNiYBmjTD1H2ya";
					var retries = 0;
					var itchstring = undefined;
					var itchstringjson = undefined;
					while (itchstring == undefined || itchstringjson == undefined || itchstringjson == json_error) && retries < 10 {
						file_delete(self.name + " itchdata.json");
						while (file_exists(self.name + " itchdata.json")) {wait 1;}
						file_download(self.url + "/data.json", self.name + " itchdata.json");
						while (!file_loaded(self.name + " itchdata.json")) {wait 1;}
						while (!file_exists(self.name + " itchdata.json")) {wait 1;}
						itchstring = string_load(self.name + " itchdata.json")
						if is_string(itchstring){
							itchstringjson = json_decode(itchstring)
						}
						retries++;
					}
					if is_undefined(itchstring) || itchstringjson == undefined || itchstringjson == json_error {
						trace("ERROR: itch link failed for " + self.name);
						trace("Please reload the weeklies mod.");
						global.qualified = false;
						break;
					}
					var modid = itchstringjson.id;
					file_delete(self.name + " data.json");
					while (file_exists(self.name + " data.json")) {wait 1;}
					if is_undefined(modid) {
						trace("ERROR: itch link failed for " + self.name);
						trace("Please reload the weeklies mod.");
						global.qualified = false;
						break;
					}
					file_download("https://api.itch.io/games/" + string(modid) + "/uploads?api_key=" + api_key, self.name + " data.json");
					while (!file_loaded(self.name + " data.json")) {wait 1;}
					while (!file_exists(self.name + " data.json")) {wait 1;}
					var out = json_decode(string_load(self.name + " data.json"));
					if("uploads" in out && array_length(out.uploads)){
						if !download_and_load(self.name, "https://api.itch.io/uploads/" + string(out.uploads[0].id) + "/download?api_key=" + api_key, out.uploads[0].filename, self.patches, self.globals) {
							trace("An error occurred during mod loading.");
							trace("Please reload the weeklies mod.");
							global.qualified = false;
							break;
						}
					}else{
						trace("ERROR: incorrect response. Recieved response was:");
						trace(out);
					}
					break;
				case "direct":
					if !download_and_load(self.name, self.url, self.filename, self.patches, self.globals) {
						trace("An error occurred during mod loading.");
						trace("Please reload the weeklies mod.");
						global.qualified = false;
						break;
					}
					break;
			}
			array_delete(global.loadticket, array_find_index(global.loadticket, name), 1);
			exit;
		}
		
		wait(0);
	}
	while(array_length(global.loadticket) > 0) wait(0)
}

wait(10);

with(GmlMod){
	if(name == "LibLoader"){cansideload=1}
}

wait(30);

global.ModNames = "";
		     
var i = 0;
for(i = 0; array_length(mod_get_names("mod")) > i; i++){
	global.ModNames += mod_get_names("mod")[i]
}
for(i = 0; array_length(mod_get_names("weapon")) > i; i++){
	global.ModNames += mod_get_names("weapon")[i]
}
for(i = 0; array_length(mod_get_names("area")) > i; i++){
	global.ModNames += mod_get_names("area")[i]
}
for(i = 0; array_length(mod_get_names("crown")) > i; i++){
	global.ModNames += mod_get_names("crown")[i]
}
for(i = 0; array_length(mod_get_names("race")) > i; i++){
	global.ModNames += mod_get_names("race")[i]
}
for(i = 0; array_length(mod_get_names("skill")) > i; i++){
	global.ModNames += mod_get_names("skill")[i]
}
for(i = 0; array_length(mod_get_names("skin")) > i; i++){
	global.ModNames += mod_get_names("skin")[i]
}

var modtext = [];
if "mods" in get_current_data() {
	with get_current_data().mods {
		array_push(modtext, self.name)
	}
}

trace("Current " + get_current_data().modeName + ":");
if("name" in get_current_data() && get_current_data().name != false) {
	trace(get_current_data().name);
}
if array_length(modtext) trace("Mods : " + array_join(modtext, ", "));
//trace("Seed : " + string(get_current_data().seed));

if(global.qualified == true && !instance_exists(CharSelect)){
	with(Player){
		instance_destroy();
		global.qualified = false;
	}
	with(Revive){
		instance_destroy();
		global.qualified = false;
	}
	trace("Disqualified for uploading results. reload the weeklies mod from the character select screen to qualify again.");
}

random_set_seed(get_seed());
game_set_seed(get_seed());

global.canStart = true;
global.active = true;

#define game_start
if(global.currentMode == "" || !global.active){
	global.active = false;
	return;
}

global.ModNames = "";
		     
var i = 0;
for(i = 0; array_length(mod_get_names("mod")) > i; i++){
	global.ModNames += mod_get_names("mod")[i]
}
for(i = 0; array_length(mod_get_names("weapon")) > i; i++){
	global.ModNames += mod_get_names("weapon")[i]
}
for(i = 0; array_length(mod_get_names("area")) > i; i++){
	global.ModNames += mod_get_names("area")[i]
}
for(i = 0; array_length(mod_get_names("crown")) > i; i++){
	global.ModNames += mod_get_names("crown")[i]
}
for(i = 0; array_length(mod_get_names("race")) > i; i++){
	global.ModNames += mod_get_names("race")[i]
}
for(i = 0; array_length(mod_get_names("skill")) > i; i++){
	global.ModNames += mod_get_names("skill")[i]
}
for(i = 0; array_length(mod_get_names("skin")) > i; i++){
	global.ModNames += mod_get_names("skin")[i]
}

random_set_seed(get_seed());
game_set_seed(get_seed());
if("disable_crowns" in get_current_data() && get_current_data().disable_crowns){
	with(GameCont){crownpoints = -(1/0)}
}
if("disable_vaults" in get_current_data() && get_current_data().disable_vaults){
	with(GameCont){vaults=100}
}
//room_speed = 30;
//current_time_scale = 1;
current_time_scale = 1/(room_speed/30);
global.finished = false;
if(global.start){
	SubmitRun();
}
UberCont.hardmode = false;
if(game_width == 426 && game_height != 240){
	game_set_size(426, 240);
}else if(game_width == 280 && game_height != 280){
	game_set_size(280, 280);
}else if game_width != 320 || game_height != 240 {
	game_set_size(320, 240);
}
global.start = true;

global.endData.alias = "";
global.endData.data = array_create(instance_number(Player));
global.endData.initialdata = array_create(instance_number(Player));
with(Player){
	if(global.endData.alias != ""){
		global.endData.alias += ", "
	}
	global.endData.alias += player_get_alias(index);
	global.endData.data[index] = {
		alias: player_get_alias(index),
		wep: wep_raw(wep),
		bwep: wep_raw(bwep),
		color: player_get_color(index),
		race: race_id < 17 && race_id > 0 ? race_id : race,
		skin: bskin
	}
	global.endData.initialdata[index] = {
		alias: player_get_alias(index),
		wep: wep_raw(wep),
		bwep: wep_raw(bwep),
		color: player_get_color(index),
		race: race_id < 17 && race_id > 0 ? race_id : race,
		skin: bskin
	}
}

var mutationList = [];
var ultraList = [];
var i = 0;
while (true) {
	var mut = skill_get_at(i++);
	if (mut == undefined) break;
		if mod_exists("skill", skill_get_at(i)) && mod_script_exists("skill", skill_get_at(i), "skill_ultra") {
			var ult = mod_script_call("skill", skill_get_at(i), "skill_ultra");
			if(is_string(ult) || is_real(ult) && ult != -1){
				array_push(ultraList, mut);
			}
		}else{
			array_push(mutationList, mut);
		}
}

with(global.endData.data) {
	for(var i = 1; i <= ultra_count(self.race); i++) {
		if ultra_get(self.race, i) {
			array_push(ultraList, [self.race, i]);
		}
	}
}
global.DataSubmission = {
	"name": global.endData.alias,
	"kills": GameCont.kills,
	"race": global.endData.data[0].race,
	"skin": global.endData.data[0].skin,
	"area": GameCont.area,
	"subarea": GameCont.subarea,
	"loop": GameCont.loops,
	"hard": GameCont.hard,
	"pizzas": 0,
	"wep": global.endData.data[0].wep,
	"bwep": global.endData.data[0].bwep,
	"crown": GameCont.crown,
	"mutations": mutationList,
	"ultras": ultraList,
	"time": GameCont.timer,
	"killed_by": GameCont.deathcause,
	"color": global.endData.data[0].color,
	"allies": global.endData.data,
	"loadout": global.endData.initialdata,
}

#define step
if(!global.finished && !instance_exists(Player) && global.start){
	SubmitRun();
}

if global.currentMode == "" {return;}

if(instance_exists(GenCont)) global.newLevel = 1;
else if(global.newLevel){
	global.newLevel = 0;
	level_start();
}

if(game_width == 426 && game_height != 240){
	game_set_size(426, 240);
}else if(game_width == 280 && game_height != 280){
	game_set_size(280, 280);
}else if game_width != 320 || game_height != 240 {
	game_set_size(320, 240);
}

if global.debug {
	for(var p = 0; p < maxp; p++){
		if button_pressed(p, "horn") {
			global.leaderboard = [];
			repeat(3){
				var ldb = []
				repeat(10) {
					var allies = [];
					var ultras = [];
					var weapons = ds_list_create();
					var mutations = [];
					var numberofweapons = weapon_get_list(weapons);
					repeat(irandom(3)+1) {
						var race = irandom(15)+1+array_length(mod_get_names("race"))
						if race > 16 {
							race = mod_get_names("race")[race-17]
						}else{
							race = race_get_name(race)
						}
						array_push(allies, {
							"alias": string(irandom(10000)),
							"race": race,
							"skin": irandom(1), //not great, but I don't want to code anything better rn
							"wep": ds_list_find_index(weapons, irandom(numberofweapons-1)),
							"bwep": ds_list_find_index(weapons, irandom(numberofweapons-1)),
							"color": irandom(10000),
						})
						array_push(ultras,[race, irandom(ultra_count(race)-1)])
					}
					var mutList = mod_get_names("skill")
					for(var i = 1; i < 30; i++) {
						array_push(mutList, i)
					}
					repeat(irandom(15)){
						array_push(mutations, mutList[irandom(array_length(mutList)-1)])
					}
					array_push(ldb, {
						"name": string(irandom(100000)),
						"kills": irandom(10000),
						"race": allies[0].race,
						"skin": allies[0].skin, //doesn't do modded skins or any number other than 2 skins
						"area": irandom(7),
						"subarea": irandom(2)+1,
						"loop": irandom(10),
						"hard": irandom(200),
						"wep": allies[0].wep,
						"bwep": allies[0].bwep,
						"crown": irandom(12)+1, //doesn't do modded crowns
						"mutations": mutations,
						"ultras": ultras, //doesn't do cultras
						"time": irandom(10000),
						"killed_by": GameCont.deathcause,
						"color": allies[0].color,
						"allies": allies,
					})
				}
				array_push(global.leaderboard, ldb)
			}
			if mod_exists("mod", "mw_ui") mod_script_call("mod", "mw_ui", "update_scoreboard");
		}
	}
}

if(global.currentMode == "" || !global.canStart){
	with(Menu){
		//race_id=[0,0,0,0] //This should be uncommented eventually, but right now it's causing odd problems
	}
	with(CharSelect){
		noinput = 3;
	}
}
cheat_check();
/*
if global.currentMode != "" {
	with(UberCont){
		if "crown" in get_current_data() && get_current_data().crown != 0 {
			for(var i = 0; i < array_length(startcrown); i++) {
				var crwn = get_current_data().crown;
				if is_array(crwn){
					if(!native_array_contains(crwn, startcrown[i], 0, array_length(crwn))){
						startcrown[i] = crwn[0];
					}
				}else{
					startcrown[i] = crwn;
				}
			}
		}
	}
}
*/
with(ProtoChest){instance_destroy();}

//This chunk is redundant and VERY slow.
/*
if(global.qualified == true && global.canStart && global.ModNames != ""){
	var ModNames = "";
		     
	var i = 0;
	for(i = 0; array_length(mod_get_names("mod")) > i; i++){
		ModNames += mod_get_names("mod")[i]
	}
	for(i = 0; array_length(mod_get_names("weapon")) > i; i++){
		ModNames += mod_get_names("weapon")[i]
	}
	for(i = 0; array_length(mod_get_names("area")) > i; i++){
		ModNames += mod_get_names("area")[i]
	}
	for(i = 0; array_length(mod_get_names("crown")) > i; i++){
		ModNames += mod_get_names("crown")[i]
	}
	for(i = 0; array_length(mod_get_names("race")) > i; i++){
		ModNames += mod_get_names("race")[i]
	}
	for(i = 0; array_length(mod_get_names("skill")) > i; i++){
		ModNames += mod_get_names("skill")[i]
	}
	for(i = 0; array_length(mod_get_names("skin")) > i; i++){
		ModNames += mod_get_names("skin")[i]
	}
	if(ModNames != global.ModNames){
		trace("Disqualified for uploading results. reload the weeklies mod from the character select screen to qualify again. Reason: Incorrect mod list");
		global.qualified = false;
	}
}
*/

with(Player){
	global.endData.data[index] = {
		alias: player_get_alias(index),
		wep: wep_raw(wep),
		bwep: wep_raw(bwep),
		color: player_get_color(index),
		race: race_id < 17 && race_id > 0 ? race_id : self.race,
		skin: bskin
	}
}

if GameCont.timer > 0 {
	var mutationList = [];
	var ultraList = [];
	var i = 0;
	while (true) {
		var mut = skill_get_at(i++);
		if (mut == undefined) break;
		if mod_exists("skill", skill_get_at(i)) && mod_script_exists("skill", skill_get_at(i), "skill_ultra") {
			var ult = mod_script_call("skill", skill_get_at(i), "skill_ultra");
			if(is_string(ult) || is_real(ult) && ult != -1){
				array_push(ultraList, mut);
			}
		}else{
			array_push(mutationList, mut);
		}
	}

	with(global.endData.data) {
		for(var i = 1; i <= ultra_count(self.race); i++) {
			if ultra_get(self.race, i) {
				array_push(ultraList, [self.race, i]);
			}
		}
	}
	var pizzas = global.DataSubmission.pizzas;
	global.DataSubmission = {
		"name": global.endData.alias,
		"kills": GameCont.kills,
		"race": global.endData.data[0].race,
		"skin": global.endData.data[0].skin,
		"area": GameCont.area,
		"subarea": GameCont.subarea,
		"loop": GameCont.loops,
		"hard": GameCont.hard,
		"pizzas": pizzas,
		"wep": global.endData.data[0].wep,
		"bwep": global.endData.data[0].bwep,
		"crown": GameCont.crown,
		"mutations": mutationList,
		"ultras": ultraList,
		"time": GameCont.timer,
		"killed_by": GameCont.deathcause,
		"color": global.endData.data[0].color,
		"allies": global.endData.data,
		"loadout": global.endData.initialdata,
	}
}

//clear game-over button
if instance_exists(GameOverButton) with GameOverButton {
	if num == 1 && !get_current_data().can_resubmit instance_delete(self);
}
	
#define draw_pause
if global.currentMode == "" {return;}
//remove restart buttons
if instance_exists(button) with button {
	if num == 1 || num == 0 {
		//instance_delete(self);
	}
}

cheat_check();
/*
with button {
	trace(variable_instance_get_names(self));
	if num == 1 instance_delete
}
*/
#define cheat_check
//Spawn setkey to prevent opening chat
if !global.debug {
	if "NoChat" in global and !instance_exists(global.NoChat) {
		with instance_create(x,y,SetKey) {
			persistent = true;
			global.NoChat = self;
		}
	}
}

//old chat failsafe is still nice as a backup
if(global.qualified){
	for(var p = 0; p < maxp; p++){
		if(button_check(p, "talk")){
			if(global.cheating[p] == 0){
				trace("PLAYER " + string(p+1) + ", IF YOU ARE NOT A CHEATER SAY SOMETHING");
				trace("DO NOT PRESS ESCAPE, DO NOT SEND AN EMPTY MESSAGE");
			}
			global.cheating[p] = 1;
			global.regChat[p] = false;
		}else if(global.cheating[p] == 1){
			if(global.regChat[p]){
				global.cheating[p] = 0;
			}else{
				trace("Player " + string(p+1) + " could have run a command, I cannot verify, this session is disqualified. Restart the session to re-qualify.");
				global.qualified = false;
				global.active = false;
				global.cheating[p] = 0;
			}
		}
	}
}

#define draw_gui
if global.currentMode == "" {return;}
if(!global.active){return;}
draw_set_font(fntSmall);
if(instance_exists(Player)) {
	if(global.qualified == true && get_current_data().valid){
		draw_text_nt(32, game_height - 6, "[" + get_current_data().modeName + "]");
	}else{
		draw_text_nt(32, game_height - 6, "[" + get_current_data().modeName + "]" + "[DISQUALIFIED]");
	}
}

#define draw_gui_end
if global.currentMode == "" {return;}
for(var p = 0; p < maxp; p++){
	if(global.cheating[p] == 1){
		draw_set_color(make_color_rgb(51, 37, 30));
		draw_rectangle(game_width/2-151, game_height/2-20, game_width/2+157, game_height/2+20, 0);
		draw_set_halign(1);
		draw_set_valign(1);
		draw_set_font(fntM);
		draw_text_nt(game_width/2+5, game_height/2, "@rPLAYER " + string(p+1) + ",#IF YOU ARE NOT A CHEATER SAY SOMETHING.#DO NOT PRESS ESCAPE,#DO NOT SEND AN EMPTY MESSAGE");
		draw_set_halign(0);
		draw_set_valign(0);
	}
}

#define chat_message(_message, _player)
global.regChat[_player] = 1;

#define loadLeaderboards()
if(fork()){
	global.leaderboard = [];
	global.headers = ds_map_create();
	ds_map_set(global.headers, "Authorization", "token 7349069d71cc5b8e1165"+"40e940c2ad5650ea32de");
	ds_map_set(global.headers, "cache-control", "no-cache");	
	ds_map_set(global.headers, "Accept", "application/vnd.github.full+json");
	with(global.modes){
		if self.name == "Invalid" {continue;}
		var dl = {scores: []};
		var ldb = dl.scores;
		file_delete("leaderboard.json");
		while (file_exists("leaderboard.json")) {wait 1;}
		http_request(`https://raw.githubusercontent.com/GoldenEpsilon/NTT-Modded-Weeklies/main/` + self.folder + `/` + getModeDate(self) + `/leaderboard.json`
		, "GET", global.headers,
		``
		, "leaderboard.json");
		while (!file_loaded("leaderboard.json")) {wait 1;}
		if(array_length(string_split(string_load("leaderboard.json"), chr(34)+"message"+chr(34)+":"+chr(34)+"Not Found"+chr(34))) == 1){
			dl = json_decode(string_load("leaderboard.json"));
		}
		file_unload("leaderboard.json");
		if dl != json_error {
			ldb = dl.scores;
		}
		self.index = array_length(global.leaderboard)
		array_push(global.leaderboard, ldb);
	}
	if mod_exists("mod", "mw_ui") mod_script_call("mod", "mw_ui", "update_scoreboard");
	exit;
}

#define getScores(sortingSystem)
	switch(sortingSystem){
		case "Kills":
			for(var i = 0; i < array_length(global.leaderboard); i++){
				native_array_sort(global.leaderboard[i], function(elm1, elm2)
				{
					return elm2.kills - elm1.kills;
				});
			}
			break;
		case "Difficulty":
			for(var i = 0; i < array_length(global.leaderboard); i++){
				native_array_sort(global.leaderboard[i], function(elm1, elm2)
				{
					return (elm2.hard != elm1.hard) ? (elm2.hard - elm1.hard) : elm2.kills - elm1.kills;
				});
			}
			break;
	}
	for (var l = 0; l < array_length(global.leaderboard); l++) {
		var leaderboard = global.leaderboard[l];
		for var i = 0; i < array_length(leaderboard); i++ {
			for var i2 = i + 1; i2 < array_length(leaderboard); i2++ {
				if string_upper(string_lettersdigits(leaderboard[i].allies[0].alias)) == string_upper(string_lettersdigits(leaderboard[i2].allies[0].alias)) {
					array_delete(global.leaderboard[l], i2, 1)
					i2--;
				}
			}
		}
	}
	return global.leaderboard;

#define getCurrentDate()
var checkDate = false
var prevDate = "";
if global.currentDate != "" {
	checkDate = true
	prevDate = global.currentDate;
}

file_download("http://yal.cc/ping", "ping.txt");
while (!file_loaded("ping.txt")) wait 1;
var unixTime = real(string_load("ping.txt")) - (3600*5); //CST
global.unixTime = unixTime;
var unixDays = floor(unixTime/86400);
var day = unixDays + 1; //(why +1?????)
var year = 1970;
while(day > 365 + isLeapYear(year)){
    year++;
    day -= 365 + isLeapYear(year);
}
var month = 1;
while(day > daysInMonth(month, year)){
    month++;
    day -= daysInMonth(month, year);
}
/*trace("Unix time at Yellow's website:", unixTime);
trace("Days since Unix Epoch:", unixDays);
trace("current year?:", year);
trace("current month?:", month);
trace("current day?:", day);
trace("current day of the week?:", (unixDays + 4) % 7);*/


var weekDay = day - (unixDays + 4) % 7;
var weekMonth = month;
var weekYear = year;
if weekDay < 1 {
	weekDay += daysInMonth(weekMonth, weekYear);
	weekMonth -= 1;
}
if weekMonth < 1 {
	weekMonth += 1;
	weekYear -= 1;
}
global.currentDate = string(year)+"-"+string_lpad(string(month), "0", 2)+"-"+string_lpad(string(day), "0", 2)
global.currentWeek = string(weekYear)+"-"+string_lpad(string(weekMonth), "0", 2)+"-"+string_lpad(string(weekDay), "0", 2)
global.countdownStart = floor(current_frame/30)
global.countdown = 86400 - (unixTime % 86400);

if checkDate && prevDate != global.currentDate {
	global.qualified = false;
	trace("It is now a different day than when the mod was loaded. You have been disqualified.");
}

#define isLeapYear(year)
return year % 4 == 0 && !(year % 100 == 0 && year % 400 == 0)

#define daysInMonth(month, year)
switch(month){
    case 1:
        return 31;
        break;
    case 2:
        return 28 + isLeapYear(year);
        break;
    case 3:
        return 31;
        break;
    case 4:
        return 30;
        break;
    case 5:
        return 31;
        break;
    case 6:
        return 30;
        break;
    case 7:
        return 31;
        break;
    case 8:
        return 31;
        break;
    case 9:
        return 30;
        break;
    case 10:
        return 31;
        break;
    case 11:
        return 30;
        break;
    case 12:
        return 31;
        break;
}

#define base64(str)
var retVal = "";
for(var i = 0; i < string_length(str)/3; i++){
	if(string_length(str)/3-i>=1){
		ord1 = string_ord_at(str, i*3+1);
		ord2 = string_ord_at(str, (i*3)+2);
		ord3 = string_ord_at(str, (i*3)+3);
		char1 = base64Char((ord1&252)/4);
		char2 = base64Char((ord1&3)*16+(ord2&240)/16);
		char3 = base64Char((ord2&15)*4+(ord3&192)/64);
		char4 = base64Char(ord3&63);
		retVal += string(char1)+string(char2)+string(char3)+string(char4);
	}else if(string_length(str) - i*3 == 2){
		ord1 = string_ord_at(str, i*3+1);
		ord2 = string_ord_at(str, (i*3)+2);
		char1 = base64Char((ord1&252)/4);
		char2 = base64Char((ord1&3)*16+(ord2&240)/16);
		char3 = base64Char((ord2&15)*4);
		retVal += string(char1)+string(char2)+string(char3)+"=";
	}else if(string_length(str) - i*3 == 1){
		ord1 = string_ord_at(str, i*3+1);
		char1 = base64Char((ord1&252)/4);
		char2 = base64Char((ord1&3)*16);
		retVal += string(char1)+string(char2)+"==";
	}
}
return retVal;
#define base64Char(num)
var retVal = "=";
switch(num){
	case 0:retVal = "A";break;
	case 1:retVal = "B";break;
	case 2:retVal = "C";break;
	case 3:retVal = "D";break;
	case 4:retVal = "E";break;
	case 5:retVal = "F";break;
	case 6:retVal = "G";break;
	case 7:retVal = "H";break;
	case 8:retVal = "I";break;
	case 9:retVal = "J";break;
	case 10:retVal = "K";break;
	case 11:retVal = "L";break;
	case 12:retVal = "M";break;
	case 13:retVal = "N";break;
	case 14:retVal = "O";break;
	case 15:retVal = "P";break;
	case 16:retVal = "Q";break;
	case 17:retVal = "R";break;
	case 18:retVal = "S";break;
	case 19:retVal = "T";break;
	case 20:retVal = "U";break;
	case 21:retVal = "V";break;
	case 22:retVal = "W";break;
	case 23:retVal = "X";break;
	case 24:retVal = "Y";break;
	case 25:retVal = "Z";break;
	case 26:retVal = "a";break;
	case 27:retVal = "b";break;
	case 28:retVal = "c";break;
	case 29:retVal = "d";break;
	case 30:retVal = "e";break;
	case 31:retVal = "f";break;
	case 32:retVal = "g";break;
	case 33:retVal = "h";break;
	case 34:retVal = "i";break;
	case 35:retVal = "j";break;
	case 36:retVal = "k";break;
	case 37:retVal = "l";break;
	case 38:retVal = "m";break;
	case 39:retVal = "n";break;
	case 40:retVal = "o";break;
	case 41:retVal = "p";break;
	case 42:retVal = "q";break;
	case 43:retVal = "r";break;
	case 44:retVal = "s";break;
	case 45:retVal = "t";break;
	case 46:retVal = "u";break;
	case 47:retVal = "v";break;
	case 48:retVal = "w";break;
	case 49:retVal = "x";break;
	case 50:retVal = "y";break;
	case 51:retVal = "z";break;
	case 52:retVal = "0";break;
	case 53:retVal = "1";break;
	case 54:retVal = "2";break;
	case 55:retVal = "3";break;
	case 56:retVal = "4";break;
	case 57:retVal = "5";break;
	case 58:retVal = "6";break;
	case 59:retVal = "7";break;
	case 60:retVal = "8";break;
	case 61:retVal = "9";break;
	case 62:retVal = "+";break;
	case 63:retVal = "/";break;
}
return retVal;
#define base64Decode(str)
var retVal = "";
for(var i = 0; i < string_length(str)/4; i++){
	if(string_length(str)/4-i>=1){
		ord1 = base64CharDecode(string_char_at(str, (i*4)+1));
		ord2 = base64CharDecode(string_char_at(str, (i*4)+2));
		ord3 = base64CharDecode(string_char_at(str, (i*4)+3));
		ord4 = base64CharDecode(string_char_at(str, (i*4)+4));
		char1 = chr(ord1 * 4 + (ord2 & 48) / 16);
		char2 = chr((ord2 & 15) * 16 + (ord3 & 60)/4);
		char3 = chr((ord3&3)*64+ord4);
		retVal += string(char1)+string(char2)+string(char3);
	}
}
return retVal;
#define base64CharDecode(str)
var retVal = 0;
switch(str){
	case "A":retVal = 0;break;
	case "B":retVal = 1;break;
	case "C":retVal = 2;break;
	case "D":retVal = 3;break;
	case "E":retVal = 4;break;
	case "F":retVal = 5;break;
	case "G":retVal = 6;break;
	case "H":retVal = 7;break;
	case "I":retVal = 8;break;
	case "J":retVal = 9;break;
	case "K":retVal = 10;break;
	case "L":retVal = 11;break;
	case "M":retVal = 12;break;
	case "N":retVal = 13;break;
	case "O":retVal = 14;break;
	case "P":retVal = 15;break;
	case "Q":retVal = 16;break;
	case "R":retVal = 17;break;
	case "S":retVal = 18;break;
	case "T":retVal = 19;break;
	case "U":retVal = 20;break;
	case "V":retVal = 21;break;
	case "W":retVal = 22;break;
	case "X":retVal = 23;break;
	case "Y":retVal = 24;break;
	case "Z":retVal = 25;break;
	case "a":retVal = 26;break;
	case "b":retVal = 27;break;
	case "c":retVal = 28;break;
	case "d":retVal = 29;break;
	case "e":retVal = 30;break;
	case "f":retVal = 31;break;
	case "g":retVal = 32;break;
	case "h":retVal = 33;break;
	case "i":retVal = 34;break;
	case "j":retVal = 35;break;
	case "k":retVal = 36;break;
	case "l":retVal = 37;break;
	case "m":retVal = 38;break;
	case "n":retVal = 39;break;
	case "o":retVal = 40;break;
	case "p":retVal = 41;break;
	case "q":retVal = 42;break;
	case "r":retVal = 43;break;
	case "s":retVal = 44;break;
	case "t":retVal = 45;break;
	case "u":retVal = 46;break;
	case "v":retVal = 47;break;
	case "w":retVal = 48;break;
	case "x":retVal = 49;break;
	case "y":retVal = 50;break;
	case "z":retVal = 51;break;
	case "0":retVal = 52;break;
	case "1":retVal = 53;break;
	case "2":retVal = 54;break;
	case "3":retVal = 55;break;
	case "4":retVal = 56;break;
	case "5":retVal = 57;break;
	case "6":retVal = 58;break;
	case "7":retVal = 59;break;
	case "8":retVal = 60;break;
	case "9":retVal = 61;break;
	case "+":retVal = 62;break;
	case "/":retVal = 63;break;
}
return retVal;

#define checkForUpdates(_name, _repo)
trace("Seeing if download is needed");
//loading the previous version file. 
//The version file is a list of commits github provides, this mod just checks the sha
file_load(_name+"oldversion.json");
while (!file_loaded(_name+"oldversion.json")) {wait 1;}
var oldjson = false;
if(file_exists(_name+"oldversion.json")){
	oldjson = json_decode(string_load(_name+"oldversion.json"));
}
file_delete(_name+"oldversion.json")

//downloading the new version file over the old one
//I delete for safety, there's a chance it isn't necessary
file_delete(_name+"version.json");
while (file_exists(_name+"version.json")) {wait 1;}
wait file_unload(_name+"version.json");
wait file_download("https://api.github.com/repos/" + _repo + "/commits", _name+"version.json");
file_load(_name+"version.json");
while (!file_loaded(_name+"version.json")) {wait 1;}
while (!file_exists(_name+"version.json")) {wait 1;}
global.newjsonstr = string_load(_name+"version.json");
var newjson = json_decode(string_load(_name+"version.json"));
wait file_unload(_name+"version.json");
if(!(global.debug && button_check(0, "horn")) && (oldjson == false || oldjson == json_error || string_length(oldjson) != string_length(newjson))){
	updateFiles(_name, _repo);
}else{
	trace("Download not needed!");
}

#define updateFiles(_name, _repo)
	trace_color("Updating Files!", c_purple);
	
	file_delete(_name+"branches.json");
	while (file_exists(_name+"branches.json")) {wait 1;}
	wait file_unload(_name+"branches.json");
	trace_color("Downloading branches...", c_purple);
	wait file_download("https://api.github.com/repos/" + _repo + "/branches", _name+"branches.json");
	trace_color("Branches downloaded...", c_purple);
	file_load(_name+"branches.json");
	while (!file_loaded(_name+"branches.json")) {wait 1;}
	while (!file_exists(_name+"branches.json")) {wait 1;}
	var branches = json_decode(string_load(_name+"branches.json"));
	wait file_unload(_name+"branches.json");
	
	if(branches != json_error){
		if(is_array(branches)){
			file_delete(_name+"tree.json");
			while (file_exists(_name+"tree.json")) {wait 1;}
			wait file_unload(_name+"tree.json");
			trace_color("Downloading commit data...", c_purple);
			wait file_download("https://api.github.com/repos/" + _repo + "/git/trees/"+branches[0].commit.sha+"?recursive=1", _name+"tree.json");
			file_load(_name+"tree.json");
			trace_color("Commit data downloaded...", c_purple);
			while (!file_loaded(_name+"tree.json")) {wait 1;}
			while (!file_exists(_name+"tree.json")) {wait 1;}
			var tree = json_decode(string_load(_name+"tree.json"));
			wait file_unload(_name+"tree.json");
			if(tree != json_error){
				with(tree.tree){
					if(type == "blob" && string_count("mod/", path) && fork()){
						var newpath = string_replace(path, "mod/", "")
						global.forks++;
						//Replace a file
						file_delete("../../mods/" + _name + "/" + newpath);
						while (file_exists("../../mods/" + _name + "/" + newpath)) {wait 1;}
						wait file_download("https://raw.githubusercontent.com/" + _repo + "/" + branches[0].name + "/" + path, "../../mods/" + _name + "/" + newpath);
						while (!file_exists("../../mods/" + _name + "/" + newpath)) {wait 1;}
						global.forks--;
						exit;
					}
				}
				wait(0);
				var forks = global.forks;
				while(global.forks > 0){
					trace_color("Update for "+_name+" is "+string(round((1-(global.forks/forks))*100))+"% done.", c_purple);
					wait(30);
				}
			}else{
				//set it to download again when it can
				file_delete(_name+"tree.json");
				trace_color("ERROR. Were you downloading too much at once?", c_purple);
			}
			if("message" in tree){
				trace_color(tree.message, c_purple);
			}
		}else{
			//set it to download again when it can
			file_delete(_name+"branches.json");
			trace_color("ERROR. Were you downloading too much at once?", c_purple);
		}
	}
	trace_color("Update for " + _name + " complete!", c_purple);
	string_save(global.newjsonstr, _name+"oldversion.json");
	while !file_exists("../../mods/" + _name + "/" + "main.txt") wait(0)
	sprite_restore(sprBackButton);
	mod_loadtext(_name + "/" + "main.txt");

#define loadModes()
global.headers = ds_map_create();
ds_map_set(global.headers, "Authorization", "token 7349069d71cc5b8e1165"+"40e940c2ad5650ea32de");
ds_map_set(global.headers, "cache-control", "no-cache");	
ds_map_set(global.headers, "Accept", "application/vnd.github.full+json");

global.data = [];

for var i = 0; i < array_length(global.modes); i++ {
	if global.modes[i].name == "Invalid" {continue;}
	file_delete("current"+global.modes[i].name+".json");
	while (file_exists("current"+global.modes[i].name+".json")) {wait 1;}
	http_request(`https://raw.githubusercontent.com/GoldenEpsilon/NTT-Modded-Weeklies/main/` + global.modes[i].folder + `/` + getModeDate(global.modes[i]) + `/data.json`
	, "GET", global.headers,
	``
	, "current"+global.modes[i].name+".json");
	while (!file_loaded("current"+global.modes[i].name+".json")) {wait 1;}
	//trace(string_load("current"+global.modes[i].name+".json"))
	var dl = {};
	var tryweekly = true;
	if(array_length(string_split(string_load("current"+global.modes[i].name+".json"), chr(34)+"message"+chr(34)+":"+chr(34)+"Not Found"+chr(34))) == 1){
		dl = json_decode(string_load("current"+global.modes[i].name+".json"));
		tryweekly = false;
		if dl == json_error {
			file_unload("current"+global.modes[i].name+".json");
			tryweekly = true;
		}
	}
	file_unload("current"+global.modes[i].name+".json");
	while (file_loaded("current"+global.modes[i].name+".json")) {wait 1;}
	if(tryweekly) {
		file_delete("current"+global.modes[i].name+".json");
		while (file_exists("current"+global.modes[i].name+".json")) {wait 1;}
		http_request(`https://raw.githubusercontent.com/GoldenEpsilon/NTT-Modded-Weeklies/main/` + global.modes[i].folder + `/` + global.currentWeek + `/data.json`
		, "GET", global.headers,
		``
		, "current"+global.modes[i].name+".json");
		while (!file_loaded("current"+global.modes[i].name+".json")) {wait 1;}
		//trace(string_load("current"+global.modes[i].name+".json"))
		dl = {};
		var trydefault = true;
		if(array_length(string_split(string_load("current"+global.modes[i].name+".json"), chr(34)+"message"+chr(34)+":"+chr(34)+"Not Found"+chr(34))) == 1){
			dl = json_decode(string_load("current"+global.modes[i].name+".json"));
			trydefault = false;
			if dl == json_error {
				file_unload("current"+global.modes[i].name+".json");
				dl = {};
				trydefault = true;
			}
		}
		file_unload("current"+global.modes[i].name+".json");
		while (file_loaded("current"+global.modes[i].name+".json")) {wait 1;}
		if(trydefault) {
			file_delete("current"+global.modes[i].name+".json");
			while (file_exists("current"+global.modes[i].name+".json")) {wait 1;}
			http_request(`https://raw.githubusercontent.com/GoldenEpsilon/NTT-Modded-Weeklies/main/` + global.modes[i].folder + `/` + "Default" + `/data.json`
			, "GET", global.headers,
			``
			, "current"+global.modes[i].name+".json");
			while (!file_loaded("current"+global.modes[i].name+".json")) {wait 1;}
			//trace(string_load("current"+global.modes[i].name+".json"))
			dl = {};
			if(array_length(string_split(string_load("current"+global.modes[i].name+".json"), chr(34)+"message"+chr(34)+":"+chr(34)+"Not Found"+chr(34))) == 1){
				dl = json_decode(string_load("current"+global.modes[i].name+".json"));
				if dl == json_error {
					file_unload("current"+global.modes[i].name+".json");
					dl = {};
				}
			}
			file_unload("current"+global.modes[i].name+".json");
			while (file_loaded("current"+global.modes[i].name+".json")) {wait 1;}
		} else {
		}
	}
	if lq_size(dl) == 0 {
		continue;
	}
	if "weekly" in dl {
		global.modes[i].weekly = dl.weekly;
	}
	if "index" not in dl {
		switch(global.modes[i].name){
			case "Modded Daily":
				dl.index = 0;
				break;
			case "Modded Weekly":
				dl.index = 1;
				break;
			case "Vanilla Daily":
				dl.index = 2;
				break;
			default:
				dl.index = i - 1;
		}
	}
	if "modeName" not in dl {
		dl.modeName = global.modes[i].name;
	}else {
		global.modes[i].name = dl.modeName;
	}
	
	if(!dl.can_resubmit) {
		while(array_length(global.leaderboard) < i){wait(1)}
		leaderboard = global.leaderboard[i-1];
		var fail = false;
		for(var i2 = 0; i2 < array_length(leaderboard); i2++){
			// Checking specifically player 1
			if string_upper(string_lettersdigits(leaderboard[i2].allies[0].alias)) == string_upper(string_lettersdigits(player_get_alias(0))) {
				fail = true;
			}
		}
		dl.valid = !fail;
	}else {
		dl.valid = true;
	}
	array_push(global.data, dl);
}

#define get_current_mode()
with(global.modes) {
	if name == global.currentMode {
		return self
	}
}
return {};

#define get_current_data()
	return get_mode_data(global.currentMode);

#define get_mode_data(mode)
	with(global.data) {
		if modeName == mode {
			return self
		}
	}
	return {};

#define download_and_load(name, url, filename, patches, globals)
trace("Downloading " + name);
//check to see if it's just a .gml before unzipping
if(string_length(filename) == 0){
	trace("ERROR: file not found. This is aserver-side issue, hopefully we are fixing it.");
	return false;
}
wait file_load("../../mods/WeeklyMods/" + name + "/version.txt");
wait file_load("../../mods/WeeklyMods/" + name + "/main.txt");
if string_load("../../mods/WeeklyMods/" + name + "/version.txt") == string(url) + string(global.currentDate) && file_exists("../../mods/WeeklyMods/" + name + "/main.txt") {
	trace(name + " Already downloaded, loading!");
} else {
	file_delete("../../mods/WeeklyMods/" + name + "/main.txt");
	while (file_exists("../../mods/WeeklyMods/" + name + "/main.txt")) {wait 1;}
	switch(string_lower(string_copy(filename, string_length(filename) - 3, 4))){
		case ".gml":
			file_delete("../../mods/WeeklyMods/" + name);
			while (file_exists("../../mods/WeeklyMods/" + name)) {wait 1;}
			file_download(url, "../../mods/WeeklyMods/" + name + "/" + filename);
			while (!file_exists("../../mods/WeeklyMods/" + name + "/" + filename)) {wait 1;}
			if string_load("../../mods/WeeklyMods/" + name + "/" + filename) == "This content is no longer available." {
				trace("ERROR: Discord link no longer works. Let Golden Epsilon know.");
				return false;
			}
			break;
		case ".zip":
			file_download(url, filename);
			recursive_delete("../../mods/WeeklyMods/" + name);
			while (!file_exists(filename)) {wait 1;}
			if string_load(filename) == "This content is no longer available." {
				trace("ERROR: Discord link no longer works. Let Golden Epsilon know.");
				return false;
			}
			trace("Unzipping " + filename);
			wait zip_unzip(filename, "../../mods/WeeklyMods/" + name);
			break;
		case ".rar":
			file_download(url, filename);
			recursive_delete("../../mods/WeeklyMods/" + name);
			while (!file_exists(filename)) {wait 1;}
			if string_load(filename) == "This content is no longer available." {
				trace("ERROR: Discord link no longer works. Let Golden Epsilon know.");
				return false;
			}
			trace("Unzipping " + filename);
			wait zip_unzip(filename, "../../mods/WeeklyMods/" + name);
			break;
		default:
			file_delete("../../mods/WeeklyMods/" + name);
			while (file_exists("../../mods/WeeklyMods/" + name)) {wait 1;}
			file_download(url, "../../mods/WeeklyMods/" + name + "/" + filename);
			while (!file_exists("../../mods/WeeklyMods/" + name + "/" + filename)) {wait 1;}
			if string_load("../../mods/WeeklyMods/" + name + "/" + filename) == "This content is no longer available." {
				trace("ERROR: Discord link no longer works. Let Golden Epsilon know.");
				return false;
			}
			break;
	}

	for(var i = 0; i < array_length(patches); i++){
		file_delete("../../mods/WeeklyMods/" + name + "/" + patches[i].file);
		while (file_exists("../../mods/WeeklyMods/" + name + "/" + patches[i].file)) {wait 1;}
		file_download(patches[i].url, "../../mods/WeeklyMods/" + name + "/" + patches[i].file);
		while (!file_exists("../../mods/WeeklyMods/" + name + "/" + patches[i].file)) {wait 1;}
		if string_load("../../mods/WeeklyMods/" + name + "/" + patches[i].file) == "This content is no longer available." {
			trace("ERROR: Discord link no longer works. Let Golden Epsilon know.");
			return false;
		}
	}

	wait(5)

	wait file_load("../../mods/WeeklyMods/" + name + "/main.txt");
	while !file_loaded("../../mods/WeeklyMods/" + name + "/main.txt") {
		wait(0)
	}
	if !file_exists("../../mods/WeeklyMods/" + name + "/main.txt") {
		var subfiles = [];
		wait file_find_all("../../mods/WeeklyMods/" + name, subfiles);
		var maintxt = "";
		with(subfiles){
			if(self.ext == ""){
				maintxt += "/load " + self.name + chr(10)
			}else if(self.ext == ".txt" && self.name != "main.txt"){
				maintxt += "/load " + self.name + chr(10)
			}else if(self.ext == ".gml"){
				maintxt += "/loadmod " + self.name + chr(10)
			}
		}
		string_save(maintxt, "../../mods/WeeklyMods/" + name + "/main.txt")
	}
	file_unload("../../mods/WeeklyMods/" + name + "/main.txt");
	while file_loaded("../../mods/WeeklyMods/" + name + "/main.txt") {
		wait(0)
	}
	wait file_load("../../mods/WeeklyMods/" + name + "/main.txt");
	while !file_loaded("../../mods/WeeklyMods/" + name + "/main.txt") {
		wait(0)
	}
	trace(name + " Downloaded!");
	string_save(string(url) + string(global.currentDate), "../../mods/WeeklyMods/" + name + "/version.txt");
}

wait(2)
while(global.loadticket[0] != name){wait(0);}
mod_loadtext("WeeklyMods/" + name + "/main.txt");

wait(2);

with(globals){
	if(fork()){
		if "mod_type" not in self {
			self.mod_type = "mod"
		}
		while(!mod_exists(self.mod_type, self.mod_name)){ wait(0) }
		mod_variable_set(self.mod_type, self.mod_name, self.variable, self.value);
		exit;
	}
}
return true;

#define getModeDate(mode)
if "weekly" in mode && mode.weekly {return global.currentWeek}
return global.currentDate

#define get_options()
return global.options

#define save_options()
if(fork()){
	file_delete("options.json")
	while(file_exists("options.json")){wait(1)}
	string_save(json_encode(global.options, "    "), "options.json")
}

#define chat_command
if(argument0 = "loaddaily"){
	if(fork()){
		global.headers = ds_map_create();
		ds_map_set(global.headers, "Authorization", "token 7349069d71cc5b8e1165"+"40e940c2ad5650ea32de");
		ds_map_set(global.headers, "cache-control", "no-cache");	
		ds_map_set(global.headers, "Accept", "application/vnd.github.full+json");
		file_delete("current"+"TESTING"+".json");
		while (file_exists("current"+"TESTING"+".json")) {wait 1;}
		http_request(`https://raw.githubusercontent.com/GoldenEpsilon/NTT-Modded-Weeklies/main/` + argument1 + `/data.json`
		, "GET", global.headers,
		``
		, "current"+"TESTING"+".json");
		while (!file_loaded("current"+"TESTING"+".json")) {wait 1;}
		//trace(string_load("current"+"TESTING"+".json"))
		var dl = {};
		if(array_length(string_split(string_load("current"+"TESTING"+".json"), chr(34)+"message"+chr(34)+":"+chr(34)+"Not Found"+chr(34))) == 1){
			dl = json_decode(string_load("current"+"TESTING"+".json"));
			if dl == json_error {
				file_unload("current"+"TESTING"+".json");
				trace(argument1 + " not found");
				exit;
			}
		}
		file_unload("current"+"TESTING"+".json");
		while (file_loaded("current"+"TESTING"+".json")) {wait 1;}
		dl.index = 0;
		dl.modeName = "TESTING";
		dl.valid = false;
		for(var i = 0; i < array_length(global.modes); i++) {
			if name == "TESTING" {
				array_delete(global.modes, i, 1)
				break;
			}
		}
		array_push(global.data, dl);
		global.currentMode = "TESTING"
		global.qualified = false;
		loadAllMods();
		exit;
	}
    return true;
}    
if(argument0 = "loaddailyfile"){
	if(fork()){
		trace("loading " + argument1);
		wait file_load("mods/" + argument1);
		while (!file_loaded("mods/" + argument1)) {wait 1;}
		var dl = {};
		dl = json_decode(string_load("mods/" + argument1));
		if dl == json_error {
			if(file_exists("mods/" + argument1)) {
				trace("mods/" + argument1 + " exists");
			}else {
				trace("mods/" + argument1 + " doesn't exist");
			}
			file_unload("mods/" + argument1);
			trace("mods/" + argument1 + " errors on loading");
			exit;
		}
		file_unload("mods/" + argument1);
		while (file_loaded("mods/" + argument1)) {wait 1;}
		dl.index = 0;
		dl.modeName = "TESTING";
		dl.valid = false;
		array_push(global.data, dl);
		global.currentMode = "TESTING"
		global.qualified = false;
		loadAllMods();
		exit;
	}
    return true;
}    

#define SubmitRun
var score = "";
with(GameCont){
	if(global.DataSubmission.kills == 0){
		global.finished = true;
		global.start = false;
		return;
	}
	var modtext = [];
	if "mods" in get_current_data() {
		with get_current_data().mods {
			array_push(modtext, self.name)
		}
	}
	score = global.endData.alias + ": Area " + string(global.DataSubmission.area) + "-" + string(global.DataSubmission.subarea) + " L" + string(global.DataSubmission.loop) + " Kills: " + string(global.DataSubmission.kills) + " Character: " + race_get_name(global.endData.data[0].race) + " Mods:" + array_join(modtext, ", ");
}
trace(score);
global.finished = true;

if(global.qualified == true && global.canStart && global.ModNames != ""){
	var ModNames = "";
		     
	var i = 0;
	for(i = 0; array_length(mod_get_names("mod")) > i; i++){
		ModNames += mod_get_names("mod")[i]
	}
	for(i = 0; array_length(mod_get_names("weapon")) > i; i++){
		ModNames += mod_get_names("weapon")[i]
	}
	for(i = 0; array_length(mod_get_names("area")) > i; i++){
		ModNames += mod_get_names("area")[i]
	}
	for(i = 0; array_length(mod_get_names("crown")) > i; i++){
		ModNames += mod_get_names("crown")[i]
	}
	for(i = 0; array_length(mod_get_names("race")) > i; i++){
		ModNames += mod_get_names("race")[i]
	}
	for(i = 0; array_length(mod_get_names("skill")) > i; i++){
		ModNames += mod_get_names("skill")[i]
	}
	for(i = 0; array_length(mod_get_names("skin")) > i; i++){
		ModNames += mod_get_names("skin")[i]
	}
	if(ModNames != global.ModNames){
		trace("Disqualified for uploading results, because mods are different. reload the weeklies mod from the character select screen to qualify again. Reason: Incorrect mod list");
		global.qualified = false;
	}
}

if(global.qualified){	
	if(fork()){
		headers = ds_map_create();
		ds_map_set(headers, "Authorization", "token 7349069d71cc5b8e1165"+"40e940c2ad5650ea32de");
		ds_map_set(headers, "cache-control", "no-cache");
		ds_map_set(headers, "Accept", "application/vnd.github.full+json");	
		file_delete("dl.txt");
		while (file_exists("dl.txt")) {wait 1;}
		http_request(`https://api.github.com/repos/GoldenEpsilon/NTT-Modded-Weeklies/contents/` + get_current_mode().folder + `/` + getModeDate(get_current_mode()) + `/leaderboard.json`
		, "GET", headers,
		``
		, "dl.txt");
		while (!file_loaded("dl.txt")) {wait 1;}
		var dl = "404";
		var leaderboard = "";
		if(string_count(`"message":"Not Found"`, string_load("dl.txt")) >= 1 || string_count(`Bad Credentials`, string_load("dl.txt")) >= 1){
			leaderboard = dl;
		}else{
			dl = string_split(string_split(string_load("dl.txt"), `","encoding":"base64"`)[0],`"content":"`)[1];
			dl = string_replace_all(dl, "\\n", "");
			leaderboard = base64Decode(dl);
		}
		file_unload("dl.txt");
		if(string_copy(leaderboard, 0, 3) == "404" || json_decode(leaderboard) == json_error){
			http_request(`https://api.github.com/repos/GoldenEpsilon/NTT-Modded-Weeklies/contents/` + get_current_mode().folder + `/` + getModeDate(get_current_mode()) + `/leaderboard.json`
			, "PUT", headers,
			`{
			"message":"Leaderboard Update (New leaderboard!) (` + global.DataSubmission.name + `)",
			"content":"`+base64(json_encode({scores: [global.DataSubmission]}, "    "))+`"
			}`
			, "out.txt");
			global.leaderboard[get_current_mode().index] = [global.DataSubmission];
			if mod_exists("mod", "mw_ui") mod_script_call("mod", "mw_ui", "update_scoreboard");
		}else{
			leaderboard = json_decode(leaderboard);
			var fail = false;
			for(var i = 0; i < array_length(leaderboard.scores); i++){
				// Checking specifically player 1
				if string_upper(string_lettersdigits(leaderboard.scores[i].allies[0].alias)) == string_upper(string_lettersdigits(global.DataSubmission.allies[0].alias)) {
					fail = true;
				}
			}
			leaderboard.scores = cleanLeaderboard(leaderboard.scores);
			array_push(leaderboard.scores, global.DataSubmission);
			if(get_current_data().can_resubmit || !fail){
				file_delete("sha.txt");
				while (file_exists("sha.txt")) {wait 1;}
				http_request(`https://api.github.com/repos/GoldenEpsilon/NTT-Modded-Weeklies/contents/` + get_current_mode().folder + `/` + getModeDate(get_current_mode()) + `/leaderboard.json`
				, "GET", headers,
				``
				, "sha.txt");
				while (!file_loaded("sha.txt")) {wait 1;}
				wait file_load("sha.txt");
				sha = string_split(string_split(string_load("sha.txt"), `"sha":"`)[1], `"`)[0];
				file_unload("sha.txt");
				http_request(`https://api.github.com/repos/GoldenEpsilon/NTT-Modded-Weeklies/contents/` + get_current_mode().folder + `/` + getModeDate(get_current_mode()) + `/leaderboard.json`
				, "PUT", headers,
				`{
				"message":"Leaderboard Update (` + global.DataSubmission.name + `)",
				"content":"`+base64(json_encode(leaderboard, "    "))+`",
				"sha":"`+sha+`"
				}`
				, "out.txt");
				global.leaderboard[get_current_mode().index] = leaderboard.scores;
				if mod_exists("mod", "mw_ui") mod_script_call("mod", "mw_ui", "update_scoreboard");
			}else{
				trace("You've already played this Daily!");
			}
		}
		if !get_current_data().can_resubmit {
			get_current_data().valid = false;
		}
		trace("Score Submitted!");
		global.start = false;
		exit;
	}
}else{
	trace("You were disqualified, so your scores were not uploaded.");
	global.start = false;
}

#define get_seed()
var seed = get_current_data().seed;
if is_string(seed) {
	var oldrseed = random_get_seed();
	switch(seed) {
		case "Daily":
			random_set_seed(floor(global.unixTime/86400))
			seed = irandom(10000000);
		break;
		case "Weekly":
			random_set_seed(floor((global.unixTime/86400)/7))
			seed = irandom(10000000);
		break;
		case "Random":
			random_set_seed(global.unixTime + current_frame)
			seed = irandom(10000000);
		break;
	}
	random_set_seed(oldrseed)
}
return seed;

#define recursive_delete(directory)
folders = [directory];
//number of searched layers
layers = 0;
//while folders has items
forks = 0;
//if it's the first scan
first = 1;
trace("Deleting old files...");
counter = 0;
while(array_length(folders) > 0 || forks > 0) {
	if(array_length(folders) > 0){
		if(fork()){
			forks++;
			var curr_folder = folders[0];
			//remove first item from folders
			folders = array_slice(folders, 1, array_length(folders) - 1);
			var temp_folders = [];
			//array that keeps track of files to see what they are
			var arr = [];
			//when folders runs out of items, for some reason it returns 0
			if(curr_folder == 0){
				forks--;
				exit;
			}
			//put all files in the directory folders[0] into arr
			wait file_find_all(curr_folder, arr);
			//for each item in arr
			for (var i = 0; i < array_length(arr); i++) {
				//"" means it's a folder, so add to temp_folders
				if(arr[i].ext == ""){
					array_push(temp_folders, arr[i].path);
				}else{
					//otherwise just file_delete
					if(fork()){
						forks++;
						wait file_load(arr[i].path)
						file_delete(arr[i].path);
						while(file_exists(arr[i].path)){wait(1)}
						file_unload(arr[i].path)
						forks--;
						exit;
					}
				}
			}
			array_copy(folders, array_length(folders), temp_folders, 0, array_length(temp_folders));
			forks--;
			first = 0;
			exit;
		}
	}else{
		wait(1);
		counter++;
		if counter > 300 {
			trace("Still deleting old files... " + string(array_length(folders) + forks) + " files/folders left to delete currently");
			counter = 0;
		}
	}
}
wait(10);

#define level_start
if GameCont.area == 102 {
	global.DataSubmission.pizzas++;
}

#define wep_raw(_wep)
	/*
		For use with LWO weapons
		Call a weapon's "weapon_raw" script in case of wrapper weapons
		
		Ex:
			wep_raw({ wep:{ wep:{ wep:123 }}}) == 123
	*/
	
	var _raw = _wep;
	
	 // Find Base Weapon:
	while(is_object(_raw)){
		_raw = (("wep" in _raw) ? _raw.wep : wep_none);
	}
	
	 // Wrapper:
	if(is_string(_raw) && mod_script_exists("weapon", _raw, "weapon_raw")){
		_raw = mod_script_call("weapon", _raw, "weapon_raw", _wep);
	}
	
	return _raw;

#define cleanLeaderboard(leaderboard)
var bestof = {}
var retLeaderboard = [];
for var i = 0; i < array_length(leaderboard); i++ {
	if lq_exists(bestof, leaderboard[i].name) {
		if lq_get(bestof, leaderboard[i].name).kills <= leaderboard[i].kills {
			lq_get(bestof, leaderboard[i].name).kills = leaderboard[i].kills
		}
		if lq_get(bestof, leaderboard[i].name).hard <= leaderboard[i].hard {
			lq_get(bestof, leaderboard[i].name).hard = leaderboard[i].hard
		}
	}else {
		lq_set(bestof, leaderboard[i].name, {
			kills: leaderboard[i].kills,
			hard: leaderboard[i].hard,
		});
	}
}
for var i = 0; i < array_length(leaderboard); i++ {
	if lq_exists(bestof, leaderboard[i].name) {
		if lq_get(bestof, leaderboard[i].name).kills <= leaderboard[i].kills || lq_get(bestof, leaderboard[i].name).hard <= leaderboard[i].hard {
			array_push(retLeaderboard, leaderboard[i])
		}
	} else {
		array_push(retLeaderboard, leaderboard[i])
	}
}
return retLeaderboard;
